<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0036)http://www.gzip.org/zlib/manual.html -->
<HTML><HEAD><TITLE>zlib general purpose compression library version 1.1.3</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type>
<META content="MSHTML 5.00.3315.2870" name=GENERATOR></HEAD>
<BODY aLink=navy bgColor=white link=red text=black vLink=red><!-- background="zlibbg.gif" -->
<H1>zlib 1.1.3 Manual </H1>
<HR>
<A name=Contents>
<H2>Contents</H2>
<OL type=I>
  <LI><A href="http://www.gzip.org/zlib/manual.html#Prologue">Prologue</A> 
  <LI><A 
  href="http://www.gzip.org/zlib/manual.html#Introduction">Introduction</A> 
  <LI><A href="http://www.gzip.org/zlib/manual.html#Utility functions">Utility 
  functions</A> 
  <LI><A href="http://www.gzip.org/zlib/manual.html#Basic functions">Basic 
  functions</A> 
  <LI><A href="http://www.gzip.org/zlib/manual.html#Advanced functions">Advanced 
  functions</A> 
  <LI><A href="http://www.gzip.org/zlib/manual.html#Constants">Constants</A> 
  <LI><A href="http://www.gzip.org/zlib/manual.html#struct z_stream_s">struct 
  z_stream_s</A> 
  <LI><A href="http://www.gzip.org/zlib/manual.html#Checksum functions">Checksum 
  functions</A> 
  <LI><A href="http://www.gzip.org/zlib/manual.html#Misc">Misc</A> </LI></OL>
<HR>
<A name=Prologue>
<H2>Prologue </H2>'zlib' general purpose compression library version 1.1.3, July 
9th, 1998 
<P>Copyright (C) 1995-1998 Jean-loup Gailly and Mark Adler 
<P>This software is provided 'as-is', without any express or implied warranty. 
In no event will the authors be held liable for any damages arising from the use 
of this software. 
<P>Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions: 
<OL>
  <LI>The origin of this software must not be misrepresented ; you must not 
  claim that you wrote the original software. If you use this software in a 
  product, an acknowledgment in the product documentation would be appreciated 
  but is not required. 
  <LI>Altered source versions must be plainly marked as such, and must not be 
  misrepresented as being the original software. 
  <LI>This notice may not be removed or altered from any source distribution. 
  </LI></OL>
<DL>
  <DT>Jean-loup Gailly 
  <DD><A href="mailto:jloup@gzip.org">jloup@gzip.org</A> 
  <DT>Mark Adler 
  <DD><A href="mailto:madler@alumni.caltech.edu">madler@alumni.caltech.edu</A> 
  </DD></DL>The data format used by the zlib library is described by RFCs (Request 
for Comments) 1950 to 1952 in the files <A 
href="ftp://ds.internic.net/rfc/rfc1950.txt">ftp://ds.internic.net/rfc/rfc1950.txt</A>(zlib 
format), <A href="ftp://ds.internic.net/rfc/rfc1951.txt">rfc1951.txt </A>(<A 
href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A> format) and <A 
href="ftp://ds.internic.net/rfc/rfc1952.txt">rfc1952.txt </A>(gzip format). 
<P>This manual is converted from zlib.h by <A 
href="mailto:piaip@csie.ntu.edu.tw">piaip </A>
<P>Visit <A 
href="http://www.info-zip.org/pub/infozip/zlib/">http://www.info-zip.org/pub/infozip/zlib/</A> 
for the official zlib web page. 
<P>
<HR>
<A name=Introduction>
<H2>Introduction </H2>The 'zlib' compression library provides in-memory 
compression and decompression functions, including integrity checks of the 
uncompressed data. This version of the library supports only one compression 
method (deflation) but other algorithms will be added later and will have the 
same stream interface. 
<P>Compression can be done in a single step if the buffers are large enough (for 
example if an input file is mmap'ed), or can be done by repeated calls of the 
compression function. In the latter case, the application must provide more 
input and/or consume the output (providing more output space) before each call. 
<P>The library also supports reading and writing files in gzip (.gz) format with 
an interface similar to that of stdio. 
<P>The library does not install any signal handler. The decoder checks the 
consistency of the compressed data, so the library should never crash even in 
case of corrupted input. 
<P>
<HR>
<A name="Utility functions">
<H2>Utility functions </H2>The following utility functions are implemented on 
top of the <A href="http://www.gzip.org/zlib/manual.html#Basic functions">basic 
stream-oriented functions</A>. To simplify the interface, some default options 
are assumed (compression level and memory usage, standard memory allocation 
functions). The source code of these utility functions can easily be modified if 
you need special options. 
<H3>Function list </H3>
<UL>
  <LI>int <A href="http://www.gzip.org/zlib/manual.html#compress">compress</A> 
  (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen); 
  <LI>int <A href="http://www.gzip.org/zlib/manual.html#compress2">compress2</A> 
  (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen, int 
  level); 
  <LI>int <A 
  href="http://www.gzip.org/zlib/manual.html#uncompress">uncompress</A> (Bytef 
  *dest, uLongf *destLen, const Bytef *source, uLong sourceLen); 
  <LI>typedef voidp gzFile; 
  <LI>gzFile <A href="http://www.gzip.org/zlib/manual.html#gzopen">gzopen</A> 
  (const char *path, const char *mode); 
  <LI>gzFile <A href="http://www.gzip.org/zlib/manual.html#gzdopen">gzdopen</A> 
  (int fd, const char *mode); 
  <LI>int <A 
  href="http://www.gzip.org/zlib/manual.html#gzsetparams">gzsetparams</A> 
  (gzFile file, int level, int strategy); 
  <LI>int <A href="http://www.gzip.org/zlib/manual.html#gzread">gzread</A> 
  (gzFile file, voidp buf, unsigned len); 
  <LI>int <A href="http://www.gzip.org/zlib/manual.html#gzwrite">gzwrite</A> 
  (gzFile file, const voidp buf, unsigned len); 
  <LI>int VA <A 
  href="http://www.gzip.org/zlib/manual.html#gzprintf">gzprintf</A> (gzFile 
  file, const char *format, ...); 
  <LI>int <A href="http://www.gzip.org/zlib/manual.html#gzputs">gzputs</A> 
  (gzFile file, const char *s); 
  <LI>char * <A href="http://www.gzip.org/zlib/manual.html#gzgets">gzgets</A> 
  (gzFile file, char *buf, int len); 
  <LI>int <A href="http://www.gzip.org/zlib/manual.html#gzputc">gzputc</A> 
  (gzFile file, int c); 
  <LI>int <A href="http://www.gzip.org/zlib/manual.html#gzgetc">gzgetc</A> 
  (gzFile file); 
  <LI>int <A href="http://www.gzip.org/zlib/manual.html#gzflush">gzflush</A> 
  (gzFile file, int flush); 
  <LI>z_off_t <A href="http://www.gzip.org/zlib/manual.html#gzseek">gzseek</A> 
  (gzFile file, z_off_t offset, int whence); 
  <LI>z_off_t <A href="http://www.gzip.org/zlib/manual.html#gztell">gztell</A> 
  (gzFile file); 
  <LI>int <A href="http://www.gzip.org/zlib/manual.html#gzrewind">gzrewind</A> 
  (gzFile file); 
  <LI>int <A href="http://www.gzip.org/zlib/manual.html#gzeof">gzeof</A> (gzFile 
  file); 
  <LI>int <A href="http://www.gzip.org/zlib/manual.html#gzclose">gzclose</A> 
  (gzFile file); 
  <LI>const char * <A 
  href="http://www.gzip.org/zlib/manual.html#gzerror">gzerror</A> (gzFile file, 
  int *errnum); </LI></UL>
<H3>Function description </H3>
<DL><FONT color=blue>
  <DT>int <A name=compress>compress</A> (Bytef *dest, uLongf *destLen, const 
  Bytef *source, uLong sourceLen);</FONT> 
  <DD>Compresses the source buffer into the destination buffer. sourceLen is the 
  byte length of the source buffer. Upon entry, destLen is the total size of the 
  destination buffer, which must be at least 0.1% larger than sourceLen plus 12 
  bytes. Upon exit, destLen is the actual size of the compressed buffer.
  <P>This function can be used to <A 
  href="http://www.gzip.org/zlib/manual.html#compress">compress</A> a whole file 
  at once if the input file is mmap'ed.
  <P><A href="http://www.gzip.org/zlib/manual.html#compress">compress</A> 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if 
  success, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_MEM_ERROR">Z_MEM_ERROR</A> if 
  there was not enough memory, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_BUF_ERROR">Z_BUF_ERROR</A> if 
  there was not enough room in the output buffer.
  <P><FONT color=blue></P>
  <DT>int <A name=compress2>compress2</A> (Bytef *dest, uLongf *destLen, const 
  Bytef *source, uLong sourceLen, int level);</FONT> 
  <DD>Compresses the source buffer into the destination buffer. The level 
  parameter has the same meaning as in <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit">deflateInit</A>. 
  sourceLen is the byte length of the source buffer. Upon entry, destLen is the 
  total size of the destination buffer, which must be at least 0.1% larger than 
  sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the 
  compressed buffer. 
  <P><A href="http://www.gzip.org/zlib/manual.html#compress2">compress2</A> 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if 
  success, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_MEM_ERROR">Z_MEM_ERROR</A> if 
  there was not enough memory, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_BUF_ERROR">Z_BUF_ERROR</A> if 
  there was not enough room in the output buffer, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_ERROR">Z_STREAM_ERROR</A> 
  if the level parameter is invalid. 
  <P><FONT color=blue></P>
  <DT>int <A name=uncompress>uncompress</A> (Bytef *dest, uLongf *destLen, const 
  Bytef *source, uLong sourceLen);</FONT> 
  <DD>Decompresses the source buffer into the destination buffer. sourceLen is 
  the byte length of the source buffer. Upon entry, destLen is the total size of 
  the destination buffer, which must be large enough to hold the entire 
  uncompressed data. (The size of the uncompressed data must have been saved 
  previously by the compressor and transmitted to the decompressor by some 
  mechanism outside the scope of this compression library.) Upon exit, destLen 
  is the actual size of the compressed buffer. 
  <P>This function can be used to decompress a whole file at once if the input 
  file is mmap'ed. 
  <P><A href="http://www.gzip.org/zlib/manual.html#uncompress">uncompress</A> 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if 
  success, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_MEM_ERROR">Z_MEM_ERROR</A> if 
  there was not enough memory, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_BUF_ERROR">Z_BUF_ERROR</A> if 
  there was not enough room in the output buffer, or <A 
  href="http://www.gzip.org/zlib/manual.html#Z_DATA_ERROR">Z_DATA_ERROR</A> if 
  the input data was corrupted. 
  <P></P>
  <DT>typedef voidp gzFile; 
  <DD>
  <P><FONT color=blue></P>
  <DT>gzFile <A name=gzopen>gzopen</A> (const char *path, const char 
  *mode);</FONT> 
  <DD>Opens a gzip (.gz) file for reading or writing. The mode parameter is as 
  in fopen ("rb" or "wb") but can also include a compression level ("wb9") or a 
  strategy: 'f' for filtered data as in "wb6f", 'h' for Huffman only compression 
  as in "wb1h". (See the description of <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit2">deflateInit2</A> for 
  more information about the strategy parameter.) 
  <P><A href="http://www.gzip.org/zlib/manual.html#gzopen">gzopen</A> can be 
  used to read a file which is not in gzip format ; in this case <A 
  href="http://www.gzip.org/zlib/manual.html#gzread">gzread</A> will directly 
  read from the file without decompression. 
  <P><A href="http://www.gzip.org/zlib/manual.html#gzopen">gzopen</A> returns 
  NULL if the file could not be opened or if there was insufficient memory to 
  allocate the (de)compression <A 
  href="http://www.gzip.org/zlib/manual.html#state">state</A> ; errno can be 
  checked to distinguish the two cases (if errno is zero, the zlib error is <A 
  href="http://www.gzip.org/zlib/manual.html#Z_MEM_ERROR">Z_MEM_ERROR</A>). 
  <P><FONT color=blue></P>
  <DT>gzFile <A name=gzdopen>gzdopen</A> (int fd, const char *mode);</FONT> 
  <DD><A href="http://www.gzip.org/zlib/manual.html#gzdopen">gzdopen</A>() 
  associates a gzFile with the file descriptor fd. File descriptors are obtained 
  from calls like open, dup, creat, pipe or fileno (in the file has been 
  previously opened with fopen). The mode parameter is as in <A 
  href="http://www.gzip.org/zlib/manual.html#gzopen">gzopen</A>. 
  <P>The next call of <A 
  href="http://www.gzip.org/zlib/manual.html#gzclose">gzclose</A> on the 
  returned gzFile will also close the file descriptor fd, just like 
  fclose(fdopen(fd), mode) closes the file descriptor fd. If you want to keep fd 
  open, use <A 
  href="http://www.gzip.org/zlib/manual.html#gzdopen">gzdopen</A>(dup(fd), 
  mode). 
  <P><A href="http://www.gzip.org/zlib/manual.html#gzdopen">gzdopen</A> returns 
  NULL if there was insufficient memory to allocate the (de)compression <A 
  href="http://www.gzip.org/zlib/manual.html#state">state</A>. 
  <P><FONT color=blue></P>
  <DT>int <A name=gzsetparams>gzsetparams</A> (gzFile file, int level, int 
  strategy);</FONT> 
  <DD>Dynamically update the compression level or strategy. See the description 
  of <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit2">deflateInit2</A> for 
  the meaning of these parameters. 
  <P><A href="http://www.gzip.org/zlib/manual.html#gzsetparams">gzsetparams</A> 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if 
  success, or <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_ERROR">Z_STREAM_ERROR</A> 
  if the file was not opened for writing. 
  <P><FONT color=blue></P>
  <DT>int <A name=gzread>gzread</A> (gzFile file, voidp buf, unsigned 
  len);</FONT> 
  <DD>Reads the given number of uncompressed bytes from the compressed file. If 
  the input file was not in gzip format, <A 
  href="http://www.gzip.org/zlib/manual.html#gzread">gzread</A> copies the given 
  number of bytes into the buffer. 
  <P><A href="http://www.gzip.org/zlib/manual.html#gzread">gzread</A> returns 
  the number of uncompressed bytes actually read (0 for end of file, -1 for 
  error). 
  <P><FONT color=blue></P>
  <DT>int <A name=gzwrite>gzwrite</A> (gzFile file, const voidp buf, unsigned 
  len);</FONT> 
  <DD>Writes the given number of uncompressed bytes into the compressed file. <A 
  href="http://www.gzip.org/zlib/manual.html#gzwrite">gzwrite</A> returns the 
  number of uncompressed bytes actually written (0 in case of error). 
  <P><FONT color=blue></P>
  <DT>int VA <A name=gzprintf>gzprintf</A> (gzFile file, const char *format, 
  ...);</FONT> 
  <DD>Converts, formats, and writes the args to the compressed file under 
  control of the format string, as in fprintf. <A 
  href="http://www.gzip.org/zlib/manual.html#gzprintf">gzprintf</A> returns the 
  number of uncompressed bytes actually written (0 in case of error). 
  <P><FONT color=blue></P>
  <DT>int <A name=gzputs>gzputs</A> (gzFile file, const char *s);</FONT> 
  <DD>Writes the given null-terminated string to the compressed file, excluding 
  the terminating null character. 
  <P><A href="http://www.gzip.org/zlib/manual.html#gzputs">gzputs</A> returns 
  the number of characters written, or -1 in case of error. 
  <P><FONT color=blue></P>
  <DT>char * <A name=gzgets>gzgets</A> (gzFile file, char *buf, int len);</FONT> 

  <DD>Reads bytes from the compressed file until len-1 characters are read, or a 
  newline character is read and transferred to buf, or an end-of-file condition 
  is encountered. The string is then terminated with a null character. 
  <P><A href="http://www.gzip.org/zlib/manual.html#gzgets">gzgets</A> returns 
  buf, or <A href="http://www.gzip.org/zlib/manual.html#Z_NULL">Z_NULL</A> in 
  case of error. 
  <P><FONT color=blue></P>
  <DT>int <A name=gzputc>gzputc</A> (gzFile file, int c);</FONT> 
  <DD>Writes c, converted to an unsigned char, into the compressed file. <A 
  href="http://www.gzip.org/zlib/manual.html#gzputc">gzputc</A> returns the 
  value that was written, or -1 in case of error. 
  <P><FONT color=blue></P>
  <DT>int <A name=gzgetc>gzgetc</A> (gzFile file);</FONT> 
  <DD>Reads one byte from the compressed file. <A 
  href="http://www.gzip.org/zlib/manual.html#gzgetc">gzgetc</A> returns this 
  byte or -1 in case of end of file or error. 
  <P><FONT color=blue></P>
  <DT>int <A name=gzflush>gzflush</A> (gzFile file, int flush);</FONT> 
  <DD>Flushes all pending output into the compressed file. The parameter flush 
  is as in the <A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A>() function. 
  The return value is the zlib error number (see function <A 
  href="http://www.gzip.org/zlib/manual.html#gzerror">gzerror</A> below). <A 
  href="http://www.gzip.org/zlib/manual.html#gzflush">gzflush</A> returns <A 
  href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if the flush 
  parameter is <A 
  href="http://www.gzip.org/zlib/manual.html#Z_FINISH">Z_FINISH</A> and all 
  output could be flushed. 
  <P><A href="http://www.gzip.org/zlib/manual.html#gzflush">gzflush</A> should 
  be called only when strictly necessary because it can degrade compression. 
  <P><FONT color=blue></P>
  <DT>z_off_t <A name=gzseek>gzseek</A> (gzFile file, z_off_t offset, int 
  whence);</FONT> 
  <DD>Sets the starting position for the next <A 
  href="http://www.gzip.org/zlib/manual.html#gzread">gzread</A> or <A 
  href="http://www.gzip.org/zlib/manual.html#gzwrite">gzwrite</A> on the given 
  compressed file. The offset represents a number of bytes in the uncompressed 
  data stream. The whence parameter is defined as in lseek(2); the value 
  SEEK_END is not supported. 
  <P>If the file is opened for reading, this function is emulated but can be 
  extremely slow. If the file is opened for writing, only forward seeks are 
  supported ; <A href="http://www.gzip.org/zlib/manual.html#gzseek">gzseek</A> 
  then compresses a sequence of zeroes up to the new starting position. 
  <P><A href="http://www.gzip.org/zlib/manual.html#gzseek">gzseek</A> returns 
  the resulting offset location as measured in bytes from the beginning of the 
  uncompressed stream, or -1 in case of error, in particular if the file is 
  opened for writing and the new starting position would be before the current 
  position. 
  <P><FONT color=blue></P>
  <DT>int <A name=gzrewind>gzrewind</A> (gzFile file);</FONT> 
  <DD>Rewinds the given file. This function is supported only for reading. 
  <P><A href="http://www.gzip.org/zlib/manual.html#gzrewind">gzrewind</A>(file) 
  is equivalent to (int)<A 
  href="http://www.gzip.org/zlib/manual.html#gzseek">gzseek</A>(file, 0L, 
  SEEK_SET) 
  <P><FONT color=blue></P>
  <DT>z_off_t <A name=gztell>gztell</A> (gzFile file);</FONT> 
  <DD>Returns the starting position for the next <A 
  href="http://www.gzip.org/zlib/manual.html#gzread">gzread</A> or <A 
  href="http://www.gzip.org/zlib/manual.html#gzwrite">gzwrite</A> on the given 
  compressed file. This position represents a number of bytes in the 
  uncompressed data stream. 
  <P><A href="http://www.gzip.org/zlib/manual.html#gztell">gztell</A>(file) is 
  equivalent to <A 
  href="http://www.gzip.org/zlib/manual.html#gzseek">gzseek</A>(file, 0L, 
  SEEK_CUR) 
  <P><FONT color=blue></P>
  <DT>int <A name=gzeof>gzeof</A> (gzFile file);</FONT> 
  <DD>Returns 1 when EOF has previously been detected reading the given input 
  stream, otherwise zero. 
  <P><FONT color=blue></P>
  <DT>int <A name=gzclose>gzclose</A> (gzFile file);</FONT> 
  <DD>Flushes all pending output if necessary, closes the compressed file and 
  deallocates all the (de)compression <A 
  href="http://www.gzip.org/zlib/manual.html#state">state</A>. The return value 
  is the zlib error number (see function <A 
  href="http://www.gzip.org/zlib/manual.html#gzerror">gzerror</A> below). 
  <P><FONT color=blue></P>
  <DT>const char * <A name=gzerror>gzerror</A> (gzFile file, int 
  *errnum);</FONT> 
  <DD>Returns the error message for the last error which occurred on the given 
  compressed file. errnum is set to zlib error number. If an error occurred in 
  the file system and not in the compression library, errnum is set to <A 
  href="http://www.gzip.org/zlib/manual.html#Z_ERRNO">Z_ERRNO</A> and the 
  application may consult errno to get the exact error code. 
  <P></P></DD></DL>
<HR>
<A name="Basic functions">
<H2>Basic functions </H2>
<H3>Function list </H3>
<UL>
  <LI>const char * <A 
  href="http://www.gzip.org/zlib/manual.html#zlibVersion">zlibVersion</A> 
  (void); 
  <LI>int <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit">deflateInit</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm, int 
  level); 
  <LI>int <A href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm, int 
  flush); 
  <LI>int <A 
  href="http://www.gzip.org/zlib/manual.html#deflateEnd">deflateEnd</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm); 
  <LI>int <A 
  href="http://www.gzip.org/zlib/manual.html#inflateInit">inflateInit</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm); 
  <LI>int <A href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm, int 
  flush); 
  <LI>int <A 
  href="http://www.gzip.org/zlib/manual.html#inflateEnd">inflateEnd</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm); 
  </LI></UL>
<H3>Function description </H3>
<DL><FONT color=blue>
  <DT>const char * <A name=zlibVersion>zlibVersion</A> (void);</FONT> 
  <DD>The application can compare <A 
  href="http://www.gzip.org/zlib/manual.html#zlibVersion">zlibVersion</A> and 
  ZLIB_VERSION for consistency. If the first character differs, the library code 
  actually used is not compatible with the zlib.h header file used by the 
  application. This check is automatically made by <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit">deflateInit</A> and <A 
  href="http://www.gzip.org/zlib/manual.html#inflateInit">inflateInit</A>. 
  <P><FONT color=blue></P>
  <DT>int <A name=deflateInit>deflateInit</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm, int 
  level);</FONT> 
  <DD>Initializes the internal stream <A 
  href="http://www.gzip.org/zlib/manual.html#state">state</A> for compression. 
  The fields <A href="http://www.gzip.org/zlib/manual.html#zalloc">zalloc</A>, 
  <A href="http://www.gzip.org/zlib/manual.html#zfree">zfree</A> and <A 
  href="http://www.gzip.org/zlib/manual.html#opaque">opaque</A> must be 
  initialized before by the caller. If <A 
  href="http://www.gzip.org/zlib/manual.html#zalloc">zalloc</A> and <A 
  href="http://www.gzip.org/zlib/manual.html#zfree">zfree</A> are set to <A 
  href="http://www.gzip.org/zlib/manual.html#Z_NULL">Z_NULL</A>, <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit">deflateInit</A> 
  updates them to use default allocation functions. 
  <P>The compression level must be <A 
  href="http://www.gzip.org/zlib/manual.html#Z_DEFAULT_COMPRESSION">Z_DEFAULT_COMPRESSION</A>, 
  or between 0 and 9: 1 gives best speed, 9 gives best compression, 0 gives no 
  compression at all (the input data is simply copied a block at a time). 
  <P><A 
  href="http://www.gzip.org/zlib/manual.html#Z_DEFAULT_COMPRESSION">Z_DEFAULT_COMPRESSION</A> 
  requests a default compromise between speed and compression (currently 
  equivalent to level 6). 
  <P><A href="http://www.gzip.org/zlib/manual.html#deflateInit">deflateInit</A> 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if 
  success, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_MEM_ERROR">Z_MEM_ERROR</A> if 
  there was not enough memory, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_ERROR">Z_STREAM_ERROR</A> 
  if level is not a valid compression level, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_VERSION_ERROR">Z_VERSION_ERROR</A> 
  if the zlib library version (<A 
  href="http://www.gzip.org/zlib/manual.html#zlib_version">zlib_version</A>) is 
  incompatible with the version assumed by the caller (ZLIB_VERSION). <A 
  href="http://www.gzip.org/zlib/manual.html#msg">msg</A> is set to null if 
  there is no error message. <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit">deflateInit</A> does 
  not perform any compression: this will be done by <A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A>(). 
  <P><FONT color=blue></P>
  <DT>int <A name=deflate>deflate</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm, int 
  flush);</FONT> 
  <DD><A href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A> 
  compresses as much data as possible, and stops when the input buffer becomes 
  empty or the output buffer becomes full. It may introduce some output latency 
  (reading input without producing any output) except when forced to flush.
  <P>The detailed semantics are as follows. <A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A> performs one 
  or both of the following actions: 
  <UL>
    <LI>Compress more input starting at <A 
    href="http://www.gzip.org/zlib/manual.html#next_in">next_in</A> and update 
    <A href="http://www.gzip.org/zlib/manual.html#next_in">next_in</A> and <A 
    href="http://www.gzip.org/zlib/manual.html#avail_in">avail_in</A> 
    accordingly. If not all input can be processed (because there is not enough 
    room in the output buffer), <A 
    href="http://www.gzip.org/zlib/manual.html#next_in">next_in</A> and <A 
    href="http://www.gzip.org/zlib/manual.html#avail_in">avail_in</A> are 
    updated and processing will resume at this point for the next call of <A 
    href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A>(). 
    <LI>Provide more output starting at <A 
    href="http://www.gzip.org/zlib/manual.html#next_out">next_out</A> and update 
    <A href="http://www.gzip.org/zlib/manual.html#next_out">next_out</A> and <A 
    href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A> 
    accordingly. This action is forced if the parameter flush is non zero. 
    Forcing flush frequently degrades the compression ratio, so this parameter 
    should be set only when necessary (in interactive applications). Some output 
    may be provided even if flush is not set. </LI></UL>
  <P>Before the call of <A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A>(), the 
  application should ensure that at least one of the actions is possible, by 
  providing more input and/or consuming more output, and updating <A 
  href="http://www.gzip.org/zlib/manual.html#avail_in">avail_in</A> or <A 
  href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A> 
  accordingly ; <A 
  href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A> should 
  never be zero before the call. The application can consume the compressed 
  output when it wants, for example when the output buffer is full (<A 
  href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A> == 0), or 
  after each call of <A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A>(). If <A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A> returns <A 
  href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> and with zero <A 
  href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A>, it must 
  be called again after making room in the output buffer because there might be 
  more output pending. 
  <P>If the parameter flush is set to <A 
  href="http://www.gzip.org/zlib/manual.html#Z_SYNC_FLUSH">Z_SYNC_FLUSH</A>, all 
  pending output is flushed to the output buffer and the output is aligned on a 
  byte boundary, so that the decompressor can get all input data available so 
  far. (In particular <A 
  href="http://www.gzip.org/zlib/manual.html#avail_in">avail_in</A> is zero 
  after the call if enough output space has been provided before the call.) 
  Flushing may degrade compression for some compression algorithms and so it 
  should be used only when necessary. 
  <P>If flush is set to <A 
  href="http://www.gzip.org/zlib/manual.html#Z_FULL_FLUSH">Z_FULL_FLUSH</A>, all 
  output is flushed as with <A 
  href="http://www.gzip.org/zlib/manual.html#Z_SYNC_FLUSH">Z_SYNC_FLUSH</A>, and 
  the compression <A href="http://www.gzip.org/zlib/manual.html#state">state</A> 
  is reset so that decompression can restart from this point if previous 
  compressed data has been damaged or if random access is desired. Using <A 
  href="http://www.gzip.org/zlib/manual.html#Z_FULL_FLUSH">Z_FULL_FLUSH</A> too 
  often can seriously degrade the compression. 
  <P>If <A href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A> 
  returns with <A 
  href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A> == 0, this 
  function must be called again with the same value of the flush parameter and 
  more output space (updated <A 
  href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A>), until 
  the flush is complete (<A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A> returns with 
  non-zero <A 
  href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A>). 
  <P>If the parameter flush is set to <A 
  href="http://www.gzip.org/zlib/manual.html#Z_FINISH">Z_FINISH</A>, pending 
  input is processed, pending output is flushed and <A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A> returns with 
  <A href="http://www.gzip.org/zlib/manual.html#Z_STREAM_END">Z_STREAM_END</A> 
  if there was enough output space ; if <A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A> returns with 
  <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A>, this function 
  must be called again with <A 
  href="http://www.gzip.org/zlib/manual.html#Z_FINISH">Z_FINISH</A> and more 
  output space (updated <A 
  href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A>) but no 
  more input data, until it returns with <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_END">Z_STREAM_END</A> or 
  an error. After <A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A> has returned 
  <A href="http://www.gzip.org/zlib/manual.html#Z_STREAM_END">Z_STREAM_END</A>, 
  the only possible operations on the stream are <A 
  href="http://www.gzip.org/zlib/manual.html#deflateReset">deflateReset</A> or 
  <A href="http://www.gzip.org/zlib/manual.html#deflateEnd">deflateEnd</A>. 
  <P><A href="http://www.gzip.org/zlib/manual.html#Z_FINISH">Z_FINISH</A> can be 
  used immediately after <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit">deflateInit</A> if all 
  the compression is to be done in a single step. In this case, <A 
  href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A> must be at 
  least 0.1% larger than <A 
  href="http://www.gzip.org/zlib/manual.html#avail_in">avail_in</A> plus 12 
  bytes. If <A href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A> 
  does not return <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_END">Z_STREAM_END</A>, 
  then it must be called again as described above. 
  <P><A href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A>() sets 
  strm-&gt; <A href="http://www.gzip.org/zlib/manual.html#adler">adler</A> to 
  the <A href="http://www.gzip.org/zlib/manual.html#adler32">adler32</A> 
  checksum of all input read so far (that is, <A 
  href="http://www.gzip.org/zlib/manual.html#total_in">total_in</A> bytes). 
  <P><A href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A>() may 
  update <A href="http://www.gzip.org/zlib/manual.html#data_type">data_type</A> 
  if it can make a good guess about the input data type (<A 
  href="http://www.gzip.org/zlib/manual.html#Z_ASCII">Z_ASCII</A> or <A 
  href="http://www.gzip.org/zlib/manual.html#Z_BINARY">Z_BINARY</A>). In doubt, 
  the data is considered binary. This field is only for information purposes and 
  does not affect the compression algorithm in any manner. 
  <P><A href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A>() 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if some 
  progress has been made (more input processed or more output produced), <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_END">Z_STREAM_END</A> if 
  all input has been consumed and all output has been produced (only when flush 
  is set to <A 
  href="http://www.gzip.org/zlib/manual.html#Z_FINISH">Z_FINISH</A>), <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_ERROR">Z_STREAM_ERROR</A> 
  if the stream <A href="http://www.gzip.org/zlib/manual.html#state">state</A> 
  was inconsistent (for example if <A 
  href="http://www.gzip.org/zlib/manual.html#next_in">next_in</A> or <A 
  href="http://www.gzip.org/zlib/manual.html#next_out">next_out</A> was NULL), 
  <A href="http://www.gzip.org/zlib/manual.html#Z_BUF_ERROR">Z_BUF_ERROR</A> if 
  no progress is possible (for example <A 
  href="http://www.gzip.org/zlib/manual.html#avail_in">avail_in</A> or <A 
  href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A> was zero). 

  <P><FONT color=blue></P>
  <DT>int <A name=deflateEnd>deflateEnd</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> 
  strm);</FONT> 
  <DD>All dynamically allocated data structures for this stream are freed. This 
  function discards any unprocessed input and does not flush any pending output. 

  <P><A href="http://www.gzip.org/zlib/manual.html#deflateEnd">deflateEnd</A> 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if 
  success, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_ERROR">Z_STREAM_ERROR</A> 
  if the stream <A href="http://www.gzip.org/zlib/manual.html#state">state</A> 
  was inconsistent, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_DATA_ERROR">Z_DATA_ERROR</A> if 
  the stream was freed prematurely (some input or output was discarded). In the 
  error case, <A href="http://www.gzip.org/zlib/manual.html#msg">msg</A> may be 
  set but then points to a static string (which must not be deallocated). 
  <P><FONT color=blue></P>
  <DT>int <A name=inflateInit>inflateInit</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> 
  strm);</FONT> 
  <DD>Initializes the internal stream <A 
  href="http://www.gzip.org/zlib/manual.html#state">state</A> for decompression. 
  The fields <A href="http://www.gzip.org/zlib/manual.html#next_in">next_in</A>, 
  <A href="http://www.gzip.org/zlib/manual.html#avail_in">avail_in</A>, <A 
  href="http://www.gzip.org/zlib/manual.html#zalloc">zalloc</A>, <A 
  href="http://www.gzip.org/zlib/manual.html#zfree">zfree</A> and <A 
  href="http://www.gzip.org/zlib/manual.html#opaque">opaque</A> must be 
  initialized before by the caller. If <A 
  href="http://www.gzip.org/zlib/manual.html#next_in">next_in</A> is not <A 
  href="http://www.gzip.org/zlib/manual.html#Z_NULL">Z_NULL</A> and <A 
  href="http://www.gzip.org/zlib/manual.html#avail_in">avail_in</A> is large 
  enough (the exact value depends on the compression method), <A 
  href="http://www.gzip.org/zlib/manual.html#inflateInit">inflateInit</A> 
  determines the compression method from the zlib header and allocates all data 
  structures accordingly ; otherwise the allocation will be deferred to the 
  first call of <A 
  href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A>. If <A 
  href="http://www.gzip.org/zlib/manual.html#zalloc">zalloc</A> and <A 
  href="http://www.gzip.org/zlib/manual.html#zfree">zfree</A> are set to <A 
  href="http://www.gzip.org/zlib/manual.html#Z_NULL">Z_NULL</A>, <A 
  href="http://www.gzip.org/zlib/manual.html#inflateInit">inflateInit</A> 
  updates them to use default allocation functions. 
  <P><A href="http://www.gzip.org/zlib/manual.html#inflateInit">inflateInit</A> 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if 
  success, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_MEM_ERROR">Z_MEM_ERROR</A> if 
  there was not enough memory, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_VERSION_ERROR">Z_VERSION_ERROR</A> 
  if the zlib library version is incompatible with the version assumed by the 
  caller. <A href="http://www.gzip.org/zlib/manual.html#msg">msg</A> is set to 
  null if there is no error message. <A 
  href="http://www.gzip.org/zlib/manual.html#inflateInit">inflateInit</A> does 
  not perform any decompression apart from reading the zlib header if present: 
  this will be done by <A 
  href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A>(). (So <A 
  href="http://www.gzip.org/zlib/manual.html#next_in">next_in</A> and <A 
  href="http://www.gzip.org/zlib/manual.html#avail_in">avail_in</A> may be 
  modified, but <A 
  href="http://www.gzip.org/zlib/manual.html#next_out">next_out</A> and <A 
  href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A> are 
  unchanged.) 
  <P><FONT color=blue></P>
  <DT>int <A name=inflate>inflate</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm, int 
  flush);</FONT> 
  <DD><A href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A> 
  decompresses as much data as possible, and stops when the input buffer becomes 
  empty or the output buffer becomes full. It may some introduce some output 
  latency (reading input without producing any output) except when forced to 
  flush. 
  <P>The detailed semantics are as follows. <A 
  href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A> performs one 
  or both of the following actions: 
  <UL>
    <LI>Decompress more input starting at <A 
    href="http://www.gzip.org/zlib/manual.html#next_in">next_in</A> and update 
    <A href="http://www.gzip.org/zlib/manual.html#next_in">next_in</A> and <A 
    href="http://www.gzip.org/zlib/manual.html#avail_in">avail_in</A> 
    accordingly. If not all input can be processed (because there is not enough 
    room in the output buffer), <A 
    href="http://www.gzip.org/zlib/manual.html#next_in">next_in</A> is updated 
    and processing will resume at this point for the next call of <A 
    href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A>(). 
    <LI>Provide more output starting at <A 
    href="http://www.gzip.org/zlib/manual.html#next_out">next_out</A> and update 
    <A href="http://www.gzip.org/zlib/manual.html#next_out">next_out</A> and <A 
    href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A> 
    accordingly. <A 
    href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A>() provides 
    as much output as possible, until there is no more input data or no more 
    space in the output buffer (see below about the flush parameter). </LI></UL>
  <P>Before the call of <A 
  href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A>(), the 
  application should ensure that at least one of the actions is possible, by 
  providing more input and/or consuming more output, and updating the next_* and 
  avail_* values accordingly. The application can consume the uncompressed 
  output when it wants, for example when the output buffer is full (<A 
  href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A> == 0), or 
  after each call of <A 
  href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A>(). If <A 
  href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A> returns <A 
  href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> and with zero <A 
  href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A>, it must 
  be called again after making room in the output buffer because there might be 
  more output pending. 
  <P>If the parameter flush is set to <A 
  href="http://www.gzip.org/zlib/manual.html#Z_SYNC_FLUSH">Z_SYNC_FLUSH</A>, <A 
  href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A> flushes as 
  much output as possible to the output buffer. The flushing behavior of <A 
  href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A> is not 
  specified for values of the flush parameter other than <A 
  href="http://www.gzip.org/zlib/manual.html#Z_SYNC_FLUSH">Z_SYNC_FLUSH</A> and 
  <A href="http://www.gzip.org/zlib/manual.html#Z_FINISH">Z_FINISH</A>, but the 
  current implementation actually flushes as much output as possible anyway. 
  <P><A href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A>() should 
  normally be called until it returns <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_END">Z_STREAM_END</A> or 
  an error. However if all decompression is to be performed in a single step (a 
  single call of <A 
  href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A>), the 
  parameter flush should be set to <A 
  href="http://www.gzip.org/zlib/manual.html#Z_FINISH">Z_FINISH</A>. In this 
  case all pending input is processed and all pending output is flushed ; <A 
  href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A> must be 
  large enough to hold all the uncompressed data. (The size of the uncompressed 
  data may have been saved by the compressor for this purpose.) The next 
  operation on this stream must be <A 
  href="http://www.gzip.org/zlib/manual.html#inflateEnd">inflateEnd</A> to 
  deallocate the decompression <A 
  href="http://www.gzip.org/zlib/manual.html#state">state</A>. The use of <A 
  href="http://www.gzip.org/zlib/manual.html#Z_FINISH">Z_FINISH</A> is never 
  required, but can be used to inform <A 
  href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A> that a faster 
  routine may be used for the single <A 
  href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A>() call. 
  <P>If a preset dictionary is needed at this point (see <A 
  href="http://www.gzip.org/zlib/manual.html#inflateSetDictionary">inflateSetDictionary</A> 
  below), <A href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A> 
  sets strm-<A href="http://www.gzip.org/zlib/manual.html#adler">adler</A> to 
  the <A href="http://www.gzip.org/zlib/manual.html#adler32">adler32</A> 
  checksum of the dictionary chosen by the compressor and returns <A 
  href="http://www.gzip.org/zlib/manual.html#Z_NEED_DICT">Z_NEED_DICT</A> ; 
  otherwise it sets strm-&gt; <A 
  href="http://www.gzip.org/zlib/manual.html#adler">adler</A> to the <A 
  href="http://www.gzip.org/zlib/manual.html#adler32">adler32</A> checksum of 
  all output produced so far (that is, <A 
  href="http://www.gzip.org/zlib/manual.html#total_out">total_out</A> bytes) and 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A>, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_END">Z_STREAM_END</A> or 
  an error code as described below. At the end of the stream, <A 
  href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A>() checks that 
  its computed <A 
  href="http://www.gzip.org/zlib/manual.html#adler32">adler32</A> checksum is 
  equal to that saved by the compressor and returns <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_END">Z_STREAM_END</A> only 
  if the checksum is correct. 
  <P><A href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A>() 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if some 
  progress has been made (more input processed or more output produced), <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_END">Z_STREAM_END</A> if 
  the end of the compressed data has been reached and all uncompressed output 
  has been produced, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_NEED_DICT">Z_NEED_DICT</A> if a 
  preset dictionary is needed at this point, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_DATA_ERROR">Z_DATA_ERROR</A> if 
  the input data was corrupted (input stream not conforming to the zlib format 
  or incorrect <A 
  href="http://www.gzip.org/zlib/manual.html#adler32">adler32</A> checksum), <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_ERROR">Z_STREAM_ERROR</A> 
  if the stream structure was inconsistent (for example if <A 
  href="http://www.gzip.org/zlib/manual.html#next_in">next_in</A> or <A 
  href="http://www.gzip.org/zlib/manual.html#next_out">next_out</A> was NULL), 
  <A href="http://www.gzip.org/zlib/manual.html#Z_MEM_ERROR">Z_MEM_ERROR</A> if 
  there was not enough memory, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_BUF_ERROR">Z_BUF_ERROR</A> if no 
  progress is possible or if there was not enough room in the output buffer when 
  <A href="http://www.gzip.org/zlib/manual.html#Z_FINISH">Z_FINISH</A> is used. 
  In the <A 
  href="http://www.gzip.org/zlib/manual.html#Z_DATA_ERROR">Z_DATA_ERROR</A> 
  case, the application may then call <A 
  href="http://www.gzip.org/zlib/manual.html#inflateSync">inflateSync</A> to 
  look for a good compression block. 
  <P><FONT color=blue></P>
  <DT>int <A name=inflateEnd>inflateEnd</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> 
  strm);</FONT> 
  <DD>All dynamically allocated data structures for this stream are freed. This 
  function discards any unprocessed input and does not flush any pending output. 

  <P><A href="http://www.gzip.org/zlib/manual.html#inflateEnd">inflateEnd</A> 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if 
  success, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_ERROR">Z_STREAM_ERROR</A> 
  if the stream <A href="http://www.gzip.org/zlib/manual.html#state">state</A> 
  was inconsistent. In the error case, <A 
  href="http://www.gzip.org/zlib/manual.html#msg">msg</A> may be set but then 
  points to a static string (which must not be deallocated). </P></DD></DL>
<HR>
<A name="Advanced functions">
<H2>Advanced functions </H2>The following functions are needed only in some 
special applications. 
<H3>Function list </H3>
<UL>
  <LI>int <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit2">deflateInit2</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm, 
  <LI>int <A 
  href="http://www.gzip.org/zlib/manual.html#deflateSetDictionary">deflateSetDictionary</A> 
  (<A href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm, 
  const Bytef *dictionary, uInt dictLength); 
  <LI>int <A 
  href="http://www.gzip.org/zlib/manual.html#deflateCopy">deflateCopy</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> dest, <A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> source); 
  <LI>int <A 
  href="http://www.gzip.org/zlib/manual.html#deflateReset">deflateReset</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm); 
  <LI>int <A 
  href="http://www.gzip.org/zlib/manual.html#deflateParams">deflateParams</A> 
  (<A href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm, 
  int level, int strategy); 
  <LI>int <A 
  href="http://www.gzip.org/zlib/manual.html#inflateInit2">inflateInit2</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm, int 
  windowBits); 
  <LI>int <A 
  href="http://www.gzip.org/zlib/manual.html#inflateSetDictionary">inflateSetDictionary</A> 
  (<A href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm, 
  const Bytef *dictionary, uInt dictLength); 
  <LI>int <A 
  href="http://www.gzip.org/zlib/manual.html#inflateSync">inflateSync</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm); 
  <LI>int <A 
  href="http://www.gzip.org/zlib/manual.html#inflateReset">inflateReset</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm); 
  </LI></UL>
<H3>Function description </H3>
<DL><FONT color=blue>
  <DT>int <A name=deflateInit2>deflateInit2</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm, int 
  level, int method, int windowBits, int memLevel, int strategy);</FONT> 
  <DD>This is another version of <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit">deflateInit</A> with 
  more compression options. The fields <A 
  href="http://www.gzip.org/zlib/manual.html#next_in">next_in</A>, <A 
  href="http://www.gzip.org/zlib/manual.html#zalloc">zalloc</A>, <A 
  href="http://www.gzip.org/zlib/manual.html#zfree">zfree</A> and <A 
  href="http://www.gzip.org/zlib/manual.html#opaque">opaque</A> must be 
  initialized before by the caller.
  <P>The method parameter is the compression method. It must be <A 
  href="http://www.gzip.org/zlib/manual.html#Z_DEFLATED">Z_DEFLATED</A> in this 
  version of the library.
  <P>The windowBits parameter is the base two logarithm of the window size (the 
  size of the history buffer). It should be in the range 8..15 for this version 
  of the library. Larger values of this parameter result in better compression 
  at the expense of memory usage. The default value is 15 if <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit">deflateInit</A> is 
  used instead.
  <P>The memLevel parameter specifies how much memory should be allocated for 
  the internal compression <A 
  href="http://www.gzip.org/zlib/manual.html#state">state</A>. memLevel=1 uses 
  minimum memory but is slow and reduces compression ratio ; memLevel=9 uses 
  maximum memory for optimal speed. The default value is 8. See zconf.h for 
  total memory usage as a function of windowBits and memLevel.
  <P>The strategy parameter is used to tune the compression algorithm. Use the 
  value <A 
  href="http://www.gzip.org/zlib/manual.html#Z_DEFAULT_STRATEGY">Z_DEFAULT_STRATEGY</A> 
  for normal data, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_FILTERED">Z_FILTERED</A> for data 
  produced by a filter (or predictor), or <A 
  href="http://www.gzip.org/zlib/manual.html#Z_HUFFMAN_ONLY">Z_HUFFMAN_ONLY</A> 
  to force Huffman encoding only (no string match). Filtered data consists 
  mostly of small values with a somewhat random distribution. In this case, the 
  compression algorithm is tuned to <A 
  href="http://www.gzip.org/zlib/manual.html#compress">compress</A> them better. 
  The effect of <A 
  href="http://www.gzip.org/zlib/manual.html#Z_FILTERED">Z_FILTERED</A> is to 
  force more Huffman coding and less string matching ; it is somewhat 
  intermediate between Z_DEFAULT and <A 
  href="http://www.gzip.org/zlib/manual.html#Z_HUFFMAN_ONLY">Z_HUFFMAN_ONLY</A>. 
  The strategy parameter only affects the compression ratio but not the 
  correctness of the compressed output even if it is not set appropriately.
  <P><A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit2">deflateInit2</A> 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if 
  success, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_MEM_ERROR">Z_MEM_ERROR</A> if 
  there was not enough memory, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_ERROR">Z_STREAM_ERROR</A> 
  if a parameter is invalid (such as an invalid method). <A 
  href="http://www.gzip.org/zlib/manual.html#msg">msg</A> is set to null if 
  there is no error message. <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit2">deflateInit2</A> does 
  not perform any compression: this will be done by <A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A>().
  <P><FONT color=blue></P>
  <DT>int <A name=deflateSetDictionary>deflateSetDictionary</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm, 
  const Bytef *dictionary, uInt dictLength);</FONT> 
  <DD>Initializes the compression dictionary from the given byte sequence 
  without producing any compressed output. This function must be called 
  immediately after <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit">deflateInit</A>, <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit2">deflateInit2</A> or 
  <A href="http://www.gzip.org/zlib/manual.html#deflateReset">deflateReset</A>, 
  before any call of <A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A>. The 
  compressor and decompressor must use exactly the same dictionary (see <A 
  href="http://www.gzip.org/zlib/manual.html#inflateSetDictionary">inflateSetDictionary</A>).
  <P>The dictionary should consist of strings (byte sequences) that are likely 
  to be encountered later in the data to be compressed, with the most commonly 
  used strings preferably put towards the end of the dictionary. Using a 
  dictionary is most useful when the data to be compressed is short and can be 
  predicted with good accuracy ; the data can then be compressed better than 
  with the default empty dictionary.
  <P>Depending on the size of the compression data structures selected by <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit">deflateInit</A> or <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit2">deflateInit2</A>, a 
  part of the dictionary may in effect be discarded, for example if the 
  dictionary is larger than the window size in <A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A> or deflate2. 
  Thus the strings most likely to be useful should be put at the end of the 
  dictionary, not at the front.
  <P>Upon return of this function, strm-&gt; <A 
  href="http://www.gzip.org/zlib/manual.html#adler">adler</A> is set to the 
  Adler32 value of the dictionary ; the decompressor may later use this value to 
  determine which dictionary has been used by the compressor. (The Adler32 value 
  applies to the whole dictionary even if only a subset of the dictionary is 
  actually used by the compressor.)
  <P><A 
  href="http://www.gzip.org/zlib/manual.html#deflateSetDictionary">deflateSetDictionary</A> 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if 
  success, or <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_ERROR">Z_STREAM_ERROR</A> 
  if a parameter is invalid (such as NULL dictionary) or the stream <A 
  href="http://www.gzip.org/zlib/manual.html#state">state</A> is inconsistent 
  (for example if <A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A> has already 
  been called for this stream or if the compression method is bsort). <A 
  href="http://www.gzip.org/zlib/manual.html#deflateSetDictionary">deflateSetDictionary</A> 
  does not perform any compression: this will be done by <A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A>().
  <P><FONT color=blue></P>
  <DT>int <A name=deflateCopy>deflateCopy</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> dest, <A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> 
  source);</FONT> 
  <DD>Sets the destination stream as a complete copy of the source stream.
  <P>This function can be useful when several compression strategies will be 
  tried, for example when there are several ways of pre-processing the input 
  data with a filter. The streams that will be discarded should then be freed by 
  calling <A 
  href="http://www.gzip.org/zlib/manual.html#deflateEnd">deflateEnd</A>. Note 
  that <A 
  href="http://www.gzip.org/zlib/manual.html#deflateCopy">deflateCopy</A> 
  duplicates the internal compression <A 
  href="http://www.gzip.org/zlib/manual.html#state">state</A> which can be quite 
  large, so this strategy is slow and can consume lots of memory.
  <P><A href="http://www.gzip.org/zlib/manual.html#deflateCopy">deflateCopy</A> 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if 
  success, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_MEM_ERROR">Z_MEM_ERROR</A> if 
  there was not enough memory, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_ERROR">Z_STREAM_ERROR</A> 
  if the source stream <A 
  href="http://www.gzip.org/zlib/manual.html#state">state</A> was inconsistent 
  (such as <A href="http://www.gzip.org/zlib/manual.html#zalloc">zalloc</A> 
  being NULL). <A href="http://www.gzip.org/zlib/manual.html#msg">msg</A> is 
  left unchanged in both source and destination.
  <P><FONT color=blue></P>
  <DT>int <A name=deflateReset>deflateReset</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> 
  strm);</FONT> 
  <DD>This function is equivalent to <A 
  href="http://www.gzip.org/zlib/manual.html#deflateEnd">deflateEnd</A> followed 
  by <A href="http://www.gzip.org/zlib/manual.html#deflateInit">deflateInit</A>, 
  but does not free and reallocate all the internal compression <A 
  href="http://www.gzip.org/zlib/manual.html#state">state</A>. The stream will 
  keep the same compression level and any other attributes that may have been 
  set by <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit2">deflateInit2</A>.
  <P><A 
  href="http://www.gzip.org/zlib/manual.html#deflateReset">deflateReset</A> 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if 
  success, or <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_ERROR">Z_STREAM_ERROR</A> 
  if the source stream <A 
  href="http://www.gzip.org/zlib/manual.html#state">state</A> was inconsistent 
  (such as <A href="http://www.gzip.org/zlib/manual.html#zalloc">zalloc</A> or 
  <A href="http://www.gzip.org/zlib/manual.html#state">state</A> being NULL).
  <P><FONT color=blue></P>
  <DT>int <A name=deflateParams>deflateParams</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm, int 
  level, int strategy);</FONT> 
  <DD>Dynamically update the compression level and compression strategy. The 
  interpretation of level and strategy is as in <A 
  href="http://www.gzip.org/zlib/manual.html#deflateInit2">deflateInit2</A>. 
  This can be used to switch between compression and straight copy of the input 
  data, or to switch to a different kind of input data requiring a different 
  strategy. If the compression level is changed, the input available so far is 
  compressed with the old level (and may be flushed); the new level will take 
  effect only at the next call of <A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A>().
  <P>Before the call of <A 
  href="http://www.gzip.org/zlib/manual.html#deflateParams">deflateParams</A>, 
  the stream <A href="http://www.gzip.org/zlib/manual.html#state">state</A> must 
  be set as for a call of <A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A>(), since the 
  currently available input may have to be compressed and flushed. In 
  particular, strm-&gt; <A 
  href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A> must be 
  non-zero.
  <P><A 
  href="http://www.gzip.org/zlib/manual.html#deflateParams">deflateParams</A> 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if 
  success, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_ERROR">Z_STREAM_ERROR</A> 
  if the source stream <A 
  href="http://www.gzip.org/zlib/manual.html#state">state</A> was inconsistent 
  or if a parameter was invalid, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_BUF_ERROR">Z_BUF_ERROR</A> if 
  strm-&gt;avail_out was zero.
  <P><FONT color=blue></P>
  <DT>int <A name=inflateInit2>inflateInit2</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm, int 
  windowBits);</FONT> 
  <DD>This is another version of <A 
  href="http://www.gzip.org/zlib/manual.html#inflateInit">inflateInit</A> with 
  an extra parameter. The fields <A 
  href="http://www.gzip.org/zlib/manual.html#next_in">next_in</A>, <A 
  href="http://www.gzip.org/zlib/manual.html#avail_in">avail_in</A>, <A 
  href="http://www.gzip.org/zlib/manual.html#zalloc">zalloc</A>, <A 
  href="http://www.gzip.org/zlib/manual.html#zfree">zfree</A> and <A 
  href="http://www.gzip.org/zlib/manual.html#opaque">opaque</A> must be 
  initialized before by the caller.
  <P>The windowBits parameter is the base two logarithm of the maximum window 
  size (the size of the history buffer). It should be in the range 8..15 for 
  this version of the library. The default value is 15 if <A 
  href="http://www.gzip.org/zlib/manual.html#inflateInit">inflateInit</A> is 
  used instead. If a compressed stream with a larger window size is given as 
  input, <A href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A>() 
  will return with the error code <A 
  href="http://www.gzip.org/zlib/manual.html#Z_DATA_ERROR">Z_DATA_ERROR</A> 
  instead of trying to allocate a larger window.
  <P><A 
  href="http://www.gzip.org/zlib/manual.html#inflateInit2">inflateInit2</A> 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if 
  success, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_MEM_ERROR">Z_MEM_ERROR</A> if 
  there was not enough memory, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_ERROR">Z_STREAM_ERROR</A> 
  if a parameter is invalid (such as a negative memLevel). <A 
  href="http://www.gzip.org/zlib/manual.html#msg">msg</A> is set to null if 
  there is no error message. <A 
  href="http://www.gzip.org/zlib/manual.html#inflateInit2">inflateInit2</A> does 
  not perform any decompression apart from reading the zlib header if present: 
  this will be done by <A 
  href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A>(). (So <A 
  href="http://www.gzip.org/zlib/manual.html#next_in">next_in</A> and <A 
  href="http://www.gzip.org/zlib/manual.html#avail_in">avail_in</A> may be 
  modified, but <A 
  href="http://www.gzip.org/zlib/manual.html#next_out">next_out</A> and <A 
  href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A> are 
  unchanged.)
  <P><FONT color=blue></P>
  <DT>int <A name=inflateSetDictionary>inflateSetDictionary</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> strm, 
  const Bytef *dictionary, uInt dictLength);</FONT> 
  <DD>Initializes the decompression dictionary from the given uncompressed byte 
  sequence. This function must be called immediately after a call of <A 
  href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A> if this call 
  returned <A 
  href="http://www.gzip.org/zlib/manual.html#Z_NEED_DICT">Z_NEED_DICT</A>. The 
  dictionary chosen by the compressor can be determined from the Adler32 value 
  returned by this call of <A 
  href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A>. The 
  compressor and decompressor must use exactly the same dictionary (see <A 
  href="http://www.gzip.org/zlib/manual.html#deflateSetDictionary">deflateSetDictionary</A>).
  <P><A 
  href="http://www.gzip.org/zlib/manual.html#inflateSetDictionary">inflateSetDictionary</A> 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if 
  success, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_ERROR">Z_STREAM_ERROR</A> 
  if a parameter is invalid (such as NULL dictionary) or the stream <A 
  href="http://www.gzip.org/zlib/manual.html#state">state</A> is inconsistent, 
  <A href="http://www.gzip.org/zlib/manual.html#Z_DATA_ERROR">Z_DATA_ERROR</A> 
  if the given dictionary doesn't match the expected one (incorrect Adler32 
  value). <A 
  href="http://www.gzip.org/zlib/manual.html#inflateSetDictionary">inflateSetDictionary</A> 
  does not perform any decompression: this will be done by subsequent calls of 
  <A href="http://www.gzip.org/zlib/manual.html#inflate">inflate</A>().
  <P><FONT color=blue></P>
  <DT>int <A name=inflateSync>inflateSync</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> 
  strm);</FONT> 
  <DD>Skips invalid compressed data until a full flush point (see above the 
  description of <A 
  href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A> with <A 
  href="http://www.gzip.org/zlib/manual.html#Z_FULL_FLUSH">Z_FULL_FLUSH</A>) can 
  be found, or until all available input is skipped. No output is provided.
  <P><A href="http://www.gzip.org/zlib/manual.html#inflateSync">inflateSync</A> 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if a full 
  flush point has been found, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_BUF_ERROR">Z_BUF_ERROR</A> if no 
  more input was provided, <A 
  href="http://www.gzip.org/zlib/manual.html#Z_DATA_ERROR">Z_DATA_ERROR</A> if 
  no flush point has been found, or <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_ERROR">Z_STREAM_ERROR</A> 
  if the stream structure was inconsistent. In the success case, the application 
  may save the current current value of <A 
  href="http://www.gzip.org/zlib/manual.html#total_in">total_in</A> which 
  indicates where valid compressed data was found. In the error case, the 
  application may repeatedly call <A 
  href="http://www.gzip.org/zlib/manual.html#inflateSync">inflateSync</A>, 
  providing more input each time, until success or end of the input data.
  <P><FONT color=blue></P>
  <DT>int <A name=inflateReset>inflateReset</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> 
  strm);</FONT> 
  <DD>This function is equivalent to <A 
  href="http://www.gzip.org/zlib/manual.html#inflateEnd">inflateEnd</A> followed 
  by <A href="http://www.gzip.org/zlib/manual.html#inflateInit">inflateInit</A>, 
  but does not free and reallocate all the internal decompression <A 
  href="http://www.gzip.org/zlib/manual.html#state">state</A>. The stream will 
  keep attributes that may have been set by <A 
  href="http://www.gzip.org/zlib/manual.html#inflateInit2">inflateInit2</A>. 
  <P><A 
  href="http://www.gzip.org/zlib/manual.html#inflateReset">inflateReset</A> 
  returns <A href="http://www.gzip.org/zlib/manual.html#Z_OK">Z_OK</A> if 
  success, or <A 
  href="http://www.gzip.org/zlib/manual.html#Z_STREAM_ERROR">Z_STREAM_ERROR</A> 
  if the source stream <A 
  href="http://www.gzip.org/zlib/manual.html#state">state</A> was inconsistent 
  (such as <A href="http://www.gzip.org/zlib/manual.html#zalloc">zalloc</A> or 
  <A href="http://www.gzip.org/zlib/manual.html#state">state</A> being NULL). 
  <P></P></DD></DL>
<HR>
<A name="Checksum functions">
<H2>Checksum functions </H2>These functions are not related to compression but 
are exported anyway because they might be useful in applications using the 
compression library. 
<H3>Function list </H3>
<UL>
  <LI>uLong <A href="http://www.gzip.org/zlib/manual.html#adler32">adler32</A> 
  (uLong <A href="http://www.gzip.org/zlib/manual.html#adler">adler</A>, const 
  Bytef *buf, uInt len); 
  <LI>uLong <A href="http://www.gzip.org/zlib/manual.html#crc32">crc32</A> 
  (uLong crc, const Bytef *buf, uInt len); </LI></UL>
<H3>Function description </H3>
<DL><FONT color=blue>
  <DT>uLong <A name=adler32>adler32</A> (uLong <A 
  href="http://www.gzip.org/zlib/manual.html#adler">adler</A>, const Bytef *buf, 
  uInt len);</FONT> 
  <DD>Update a running Adler-32 checksum with the bytes buf[0..len-1] and return 
  the updated checksum. If buf is NULL, this function returns the required 
  initial value for the checksum. 
  <P>An Adler-32 checksum is almost as reliable as a CRC32 but can be computed 
  much faster. Usage example: <PRE>
     uLong <A href="http://www.gzip.org/zlib/manual.html#adler">adler</A> = <A href="http://www.gzip.org/zlib/manual.html#adler32">adler32</A>(0L, <A href="http://www.gzip.org/zlib/manual.html#Z_NULL">Z_NULL</A>, 0);

     while (read_buffer(buffer, length) != EOF) {
       <A href="http://www.gzip.org/zlib/manual.html#adler">adler</A> = <A href="http://www.gzip.org/zlib/manual.html#adler32">adler32</A>(<A href="http://www.gzip.org/zlib/manual.html#adler">adler</A>, buffer, length);
     }
     if (<A href="http://www.gzip.org/zlib/manual.html#adler">adler</A> != original_adler) error();
   </PRE><FONT color=blue>
  <DT>uLong <A name=crc32>crc32</A> (uLong crc, const Bytef *buf, uInt 
  len);</FONT> 
  <DD>Update a running crc with the bytes buf[0..len-1] and return the updated 
  crc. If buf is NULL, this function returns the required initial value for the 
  crc. Pre- and post-conditioning (one's complement) is performed within this 
  function so it shouldn't be done by the application. Usage example: <PRE>
     uLong crc = <A href="http://www.gzip.org/zlib/manual.html#crc32">crc32</A>(0L, <A href="http://www.gzip.org/zlib/manual.html#Z_NULL">Z_NULL</A>, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = <A href="http://www.gzip.org/zlib/manual.html#crc32">crc32</A>(crc, buffer, length);
     }
     if (crc != original_crc) error();
   </PRE></DD></DL>
<HR>
<A name="struct z_stream_s">
<H2>struct z_stream_s </H2><FONT color=blue><A name=z_stream_s><PRE>typedef struct z_stream_s {
    Bytef    *<A name=next_in>next_in</A>;  /* next input byte */
    uInt     <A name=avail_in>avail_in</A>;  /* number of bytes available at <A href="http://www.gzip.org/zlib/manual.html#next_in">next_in</A> */
    uLong    <A name=total_in>total_in</A>;  /* total nb of input bytes read so far */

    Bytef    *<A name=next_out>next_out</A>; /* next output byte should be put there */
    uInt     <A name=avail_out>avail_out</A>; /* remaining free space at <A href="http://www.gzip.org/zlib/manual.html#next_out">next_out</A> */
    uLong    <A name=total_out>total_out</A>; /* total nb of bytes output so far */

    char     *<A name=msg>msg</A>;      /* last error message, NULL if no error */
    struct internal_state FAR *<A name=state>state</A>; /* not visible by applications */

    alloc_func <A name=zalloc>zalloc</A>;  /* used to allocate the internal <A href="http://www.gzip.org/zlib/manual.html#state">state</A> */
    free_func  <A name=zfree>zfree</A>;   /* used to free the internal <A href="http://www.gzip.org/zlib/manual.html#state">state</A> */
    voidpf     <A name=opaque>opaque</A>;  /* private data object passed to <A href="http://www.gzip.org/zlib/manual.html#zalloc">zalloc</A> and <A href="http://www.gzip.org/zlib/manual.html#zfree">zfree</A> */

    int     <A name=data_type>data_type</A>;  /* best guess about the data type: ascii or binary */
    uLong   <A name=adler>adler</A>;      /* <A href="http://www.gzip.org/zlib/manual.html#adler32">adler32</A> value of the uncompressed data */
    uLong   <A name=reserved>reserved</A>;   /* <A href="http://www.gzip.org/zlib/manual.html#reserved">reserved</A> for future use */
} <A href="http://www.gzip.org/zlib/manual.html#z_stream_s">z_stream</A> ;

typedef <A href="http://www.gzip.org/zlib/manual.html#z_stream_s">z_stream</A> FAR * <A name=z_streamp>z_streamp</A>;   
</PRE></FONT>The application must update <A 
href="http://www.gzip.org/zlib/manual.html#next_in">next_in</A> and <A 
href="http://www.gzip.org/zlib/manual.html#avail_in">avail_in</A> when <A 
href="http://www.gzip.org/zlib/manual.html#avail_in">avail_in</A> has dropped to 
zero. It must update <A 
href="http://www.gzip.org/zlib/manual.html#next_out">next_out</A> and <A 
href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A> when <A 
href="http://www.gzip.org/zlib/manual.html#avail_out">avail_out</A> has dropped 
to zero. The application must initialize <A 
href="http://www.gzip.org/zlib/manual.html#zalloc">zalloc</A>, <A 
href="http://www.gzip.org/zlib/manual.html#zfree">zfree</A> and <A 
href="http://www.gzip.org/zlib/manual.html#opaque">opaque</A> before calling the 
init function. All other fields are set by the compression library and must not 
be updated by the application. 
<P>The <A href="http://www.gzip.org/zlib/manual.html#opaque">opaque</A> value 
provided by the application will be passed as the first parameter for calls of 
<A href="http://www.gzip.org/zlib/manual.html#zalloc">zalloc</A> and <A 
href="http://www.gzip.org/zlib/manual.html#zfree">zfree</A>. This can be useful 
for custom memory management. The compression library attaches no meaning to the 
<A href="http://www.gzip.org/zlib/manual.html#opaque">opaque</A> value. 
<P><A href="http://www.gzip.org/zlib/manual.html#zalloc">zalloc</A> must return 
<A href="http://www.gzip.org/zlib/manual.html#Z_NULL">Z_NULL</A> if there is not 
enough memory for the object. If zlib is used in a multi-threaded application, 
<A href="http://www.gzip.org/zlib/manual.html#zalloc">zalloc</A> and <A 
href="http://www.gzip.org/zlib/manual.html#zfree">zfree</A> must be thread safe. 

<P>On 16-bit systems, the functions <A 
href="http://www.gzip.org/zlib/manual.html#zalloc">zalloc</A> and <A 
href="http://www.gzip.org/zlib/manual.html#zfree">zfree</A> must be able to 
allocate exactly 65536 bytes, but will not be required to allocate more than 
this if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS, 
pointers returned by <A 
href="http://www.gzip.org/zlib/manual.html#zalloc">zalloc</A> for objects of 
exactly 65536 bytes *must* have their offset normalized to zero. The default 
allocation function provided by this library ensures this (see zutil.c). To 
reduce memory requirements and avoid any allocation of 64K objects, at the 
expense of compression ratio, compile the library with -DMAX_WBITS=14 (see 
zconf.h). 
<P>The fields <A 
href="http://www.gzip.org/zlib/manual.html#total_in">total_in</A> and <A 
href="http://www.gzip.org/zlib/manual.html#total_out">total_out</A> can be used 
for statistics or progress reports. After compression, <A 
href="http://www.gzip.org/zlib/manual.html#total_in">total_in</A> holds the 
total size of the uncompressed data and may be saved for use in the decompressor 
(particularly if the decompressor wants to decompress everything in a single 
step). 
<P>
<HR>
<A name=Constants>
<H2>Constants </H2><FONT color=blue><PRE>#define <A name=Z_NO_FLUSH>Z_NO_FLUSH</A>      0
#define <A name=Z_PARTIAL_FLUSH>Z_PARTIAL_FLUSH</A> 1 
	/* will be removed, use <A href="http://www.gzip.org/zlib/manual.html#Z_SYNC_FLUSH">Z_SYNC_FLUSH</A> instead */
#define <A name=Z_SYNC_FLUSH>Z_SYNC_FLUSH</A>    2
#define <A name=Z_FULL_FLUSH>Z_FULL_FLUSH</A>    3
#define <A name=Z_FINISH>Z_FINISH</A>        4
/* Allowed flush values ; see <A href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A>() below for details */

#define <A name=Z_OK>Z_OK</A>            0
#define <A name=Z_STREAM_END>Z_STREAM_END</A>    1
#define <A name=Z_NEED_DICT>Z_NEED_DICT</A>     2
#define <A name=Z_ERRNO>Z_ERRNO</A>        (-1)
#define <A name=Z_STREAM_ERROR>Z_STREAM_ERROR</A> (-2)
#define <A name=Z_DATA_ERROR>Z_DATA_ERROR</A>   (-3)
#define <A name=Z_MEM_ERROR>Z_MEM_ERROR</A>    (-4)
#define <A name=Z_BUF_ERROR>Z_BUF_ERROR</A>    (-5)
#define <A name=Z_VERSION_ERROR>Z_VERSION_ERROR</A> (-6)
/* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 */

#define <A name=Z_NO_COMPRESSION>Z_NO_COMPRESSION</A>         0
#define <A name=Z_BEST_SPEED>Z_BEST_SPEED</A>             1
#define <A name=Z_BEST_COMPRESSION>Z_BEST_COMPRESSION</A>       9
#define <A name=Z_DEFAULT_COMPRESSION>Z_DEFAULT_COMPRESSION</A>  (-1)
/* compression levels */

#define <A name=Z_FILTERED>Z_FILTERED</A>            1
#define <A name=Z_HUFFMAN_ONLY>Z_HUFFMAN_ONLY</A>        2
#define <A name=Z_DEFAULT_STRATEGY>Z_DEFAULT_STRATEGY</A>    0
/* compression strategy ; see <A href="http://www.gzip.org/zlib/manual.html#deflateInit2">deflateInit2</A>() below for details */

#define <A name=Z_BINARY>Z_BINARY</A>   0
#define <A name=Z_ASCII>Z_ASCII</A>    1
#define <A name=Z_UNKNOWN>Z_UNKNOWN</A>  2
/* Possible values of the <A href="http://www.gzip.org/zlib/manual.html#data_type">data_type</A> field */

#define <A name=Z_DEFLATED>Z_DEFLATED</A>   8
/* The <A href="http://www.gzip.org/zlib/manual.html#deflate">deflate</A> compression method (the only one supported in this version) */

#define <A name=Z_NULL>Z_NULL</A>  0  /* for initializing <A href="http://www.gzip.org/zlib/manual.html#zalloc">zalloc</A>, <A href="http://www.gzip.org/zlib/manual.html#zfree">zfree</A>, <A href="http://www.gzip.org/zlib/manual.html#opaque">opaque</A> */

#define <A name=zlib_version>zlib_version</A> <A href="http://www.gzip.org/zlib/manual.html#zlibVersion">zlibVersion</A>()
/* for compatibility with versions less than 1.0.2 */
</PRE></FONT>
<HR>
<A name=Misc>
<H2>Misc </H2><A 
href="http://www.gzip.org/zlib/manual.html#deflateInit">deflateInit</A> and <A 
href="http://www.gzip.org/zlib/manual.html#inflateInit">inflateInit</A> are 
macros to allow checking the zlib version and the compiler's view of <A 
href="http://www.gzip.org/zlib/manual.html#z_stream_s">z_stream</A>. 
<P>Other functions: 
<DL><FONT color=blue>
  <DT>const char * <A name=zError>zError</A> (int err);</FONT> <FONT color=blue>
  <DT>int <A name=inflateSyncPoint>inflateSyncPoint</A> (<A 
  href="http://www.gzip.org/zlib/manual.html#z_streamp">z_streamp</A> z);</FONT> 
  <FONT color=blue>
  <DT>const uLongf * <A name=get_crc_table>get_crc_table</A> (void);</FONT> 
</DT></DL>
<HR>
<FONT size=-1>Last update: Wed Oct 13 20:42:34 1999<BR>piaip@csie.ntu.edu.tw 
</FONT></BODY></HTML>
